<?php
/**
 * User: F4N70M
 * Version: 0.1
 * Date: 03.06.2020
 */

namespace Fw\Components\Services\Database;


use Exception;

class EntityQueryBuilder extends QueryBuilder
{
	protected $entities = [
		'auth'  =>  [
			'columns'   =>  [],
			'types'     =>  false,
			'meta'      =>  false,
			'relations' =>  true
		],
		'events'  =>  [
			'columns'   =>  [],
			'types'     =>  false,
			'meta'      =>  false,
			'relations' =>  false
		],
		'files'  =>  [
			'columns'   =>  [],
			'types'     =>  false,
			'meta'      =>  false,
			'relations' =>  false
		],
		'links'  =>  [
			'columns'   =>  [],
			'types'     =>  false,
			'meta'      =>  false,
			'relations' =>  false
		],
		'objects'  =>  [
			'columns'   =>  [],
			'types'     =>  true,
			'meta'      =>  true,
			'relations' =>  true
		],
		'options'  =>  [
			'columns'   =>  [],
			'types'     =>  false,
			'meta'      =>  false,
			'relations' =>  false
		],
		'users'  =>  [
			'columns'   =>  [],
			'types'     =>  true,
			'meta'      =>  false,
			'relations' =>  false
		],
        'vars'  =>  [
            'columns'   =>  [],
            'types'     =>  true,
            'meta'      =>  true,
            'relations' =>  false
        ],
        'relations'  =>  [
            'columns'   =>  [],
            'types'     =>  false,
            'meta'      =>  false,
            'relations' =>  false
        ]
	];

	public $microtime = [];


	/**
	 * @param array $values
	 * @return QueryBuilder
	 * @throws Exception
	 */
	public function values(array $values = [])
	{
		$entityName = $this->query['into'];
		// convert type name to id
		if (!empty($this->getEntityTypes($entityName)) && array_key_exists('type', $values))
		{
			$values['type'] = array_search($values['type'], $this->getEntityTypes($entityName));
		}
		return parent ::values($values); // TODO: Change the autogenerated stub
	}


    /**
     * @param bool $columnKey
     * @return array|bool|mixed
     * @throws Exception
     */
	public function result($columnKey=false)
	{
		switch ($this->query['action'])
		{
			case "SELECT":
				$result = $this->resultSelect($this->query, $this->bind, $columnKey);
				break;
			case "INSERT":
				$result = $this->resultInsert($this->query, $this->bind);
				break;
			case "UPDATE":
				$result = $this->resultUpdate($this->query, $this->bind);
				break;
			case "DELETE":
				$result = $this->resultDelete($this->query, $this->bind);
				break;
			default:
				$result = parent::result($columnKey);
				break;
		}
		return $result;
	}


	public function debug()
    {
        $result = $this->result();
//        debug($this->query,$this->bind);
        return $result;
    }




	/**
	 * @param array $queryParts
	 * @param array $bind
	 * @return array|mixed
	 * @throws Exception
	 */
	protected function resultSelect(array $queryParts, array $bind, $columnKey=false)
	{
		$sql = $this->getConvertQuerySelect($queryParts);
		$statement = $this->prepare($sql, $bind);
        $start = microtime(true);
		$statement = $this->execute($statement);
//        debug(microtime(true) - $start);
		$result = $this->getStatementResult($queryParts['action'], $statement, $columnKey);

		if ($result)
			$result = $this->resultSelectDiscardExcess($queryParts['from'], $result);

        $this->connection->microtime[] = [
            microtime(true) - $start,
            $sql,
            $bind
        ];

		return $result;
	}




    /**
     * @param array $parts
     * @return string
     * @throws Exception
     */
    protected function getConvertQuerySelect(array $parts)
    {
        $entityName = $parts['from'];
        $fromQuery = $this->getEntitySubQuerySelect($entityName, $parts['columns']);
        $q = "SELECT {$parts['columns']} FROM ({$fromQuery}) r";

        if (isset($parts['where'])) $q .= " WHERE {$parts['where']}";
        if (isset($parts['orderBy'])) $q .= " ORDER BY {$parts['orderBy']}";
        if (isset($parts['limit'])) $q .= " LIMIT {$parts['limit']}";

        return $q;
    }

    protected function getArrayQueryColumns(string $queryColumns)
    {
        if ($queryColumns == '*') return false;

        $explode = explode(',', $queryColumns);
        $result = [];
        foreach ($explode as $key => $column)
        {
            $column = trim($column);
            $result[$column] = $column;
        }
        return $result;
    }

    /**
     * @param string $entityName
     * @return string
     * @throws Exception
     */
    protected function getEntitySubQuerySelect(string $entityName, $queryColumns = '*')
    {

        $explodeQueryColumns = $this->getArrayQueryColumns($queryColumns);


        $defaultColumns  = $this->getTableColumns($entityName);
        $metaKeys = $this->getEntityMetaKeys($entityName);

        $joins = [];

        $diffColumns = array_diff($defaultColumns,['type']);
        $tableName = 'm';
        $columns = [];
        foreach ($diffColumns as $key => $item)
        {
            $columns[$item] = "{$tableName}.{$item}";
        }
//        array_walk($columns, function(&$item, $key, $tableName) {
//            $item = "{$tableName}.{$item}";
//        },$tableName);
        // TYPES
        if ($this->getEntityTypes($entityName))
        {
            if ($explodeQueryColumns) $explodeQueryColumns['type'] = 'type';
            $columns['type'] = 't.name type';
            $joins['type'] = "LEFT JOIN {$entityName}_types t ON m.type=t.id";
        }
        // META KEYS
        if ($metaKeys)
        {
            foreach ($metaKeys as $key => $metaKey)
            {
                $column = "{$metaKey['meta_key']}.meta_value {$metaKey['meta_key']}";
                $join =
                    "LEFT JOIN {$entityName}_meta {$metaKey['meta_key']}".
                    " ON {$metaKey['meta_key']}.meta_key='{$metaKey['meta_key']}' && {$metaKey['meta_key']}.item_id=m.id";
                if (!in_array($join, $joins))
                {
                    $columns[$metaKey['meta_key']] = $column;
                    $joins[$metaKey['meta_key']] = $join;
                }
            }
        }

        if ($explodeQueryColumns)
        {
            $columns = array_intersect_key($columns, $explodeQueryColumns);
            $joins = array_intersect_key($joins, $explodeQueryColumns);
//            debug(
//                $explodeQueryColumns,
//                $columns,
//                $joins
//            );
        }
        $strColumns = implode(', ', $columns);
        $strJoins = implode(' ', $joins);
        $subQuery = "SELECT {$strColumns} FROM {$entityName} m {$strJoins}";

        return $subQuery;
    }

    /**
     * @param $entityName
     * @return mixed
     * @throws Exception
     */
    private function getEntityTypes($entityName)
    {
        if (!isset($this->entities[$entityName]['types'])) debug($entityName);
        if (
            $this->entities[$entityName]['types'] !== false
            &&
            !(is_array($this->entities[$entityName]['types']) && !empty($this->entities[$entityName]['types']))
        )
        {
            $stmt = $this->prepare("SELECT * FROM {$entityName}_types", []);
            $stmt = $this->execute($stmt);
            $result = $this->getStatementResult('SELECT', $stmt);
            $types = [];
            if($result)
            {
                foreach ($result as $type) {
                    $types[$type['id']] = $type['name'];
                }
            }
            $this->entities[$entityName]['types'] = $types;
        }
        return $this->entities[$entityName]['types'];
    }

	/**
	 * @param array $queryParts
	 * @param array $bind
	 * @return mixed
	 * @throws Exception
	 */
	protected function resultInsert(array $queryParts, array $bind)
	{
		$entityName = $queryParts['into'];
		$columns = $this->getTableColumns($entityName);
		$metaKeys = $this->getEntityMetaKeys($entityName);

		if ($validateNameResult = $this->validateNameColumn($entityName, $columns, $queryParts['values'], $bind))
        {
            $queryParts['values'] = $validateNameResult['values'];
            $bind = $validateNameResult['bind'];
        }

		$insertParts = $queryParts;
		$insertParts['values'] = array_intersect_key($queryParts['values'], array_flip($columns));
		$insertBind   = array_intersect_key($bind, array_flip($insertParts['values']));
		$sql = $this->getConvertQuery($insertParts);
		$statement = $this->prepare($sql, $insertBind);
		$statement = $this->execute($statement);
		$insertId = $this->getStatementResult($insertParts['action'], $statement);

		if ($insertId)
		{
			foreach ($metaKeys as $metaKey)
			{
				if (key_exists($metaKey['meta_key'], $queryParts['values']))
				{
					$this->insertMetaValue($entityName, $insertId, $metaKey['meta_key'], $bind[$queryParts['values'][$metaKey['meta_key']]]);
					unset($queryParts['values'][$metaKey['meta_key']]);
				}
			}
		}

		return $insertId;
	}

	protected function validateNameColumn(string $entityName, array $columns, array $values, array $bind)
    {
        if (
            in_array('name', $columns)
            && in_array('title', $columns)
            && (!isset($values['name']) || (isset($values['name']) && !empty($values['name'])))
        )
        {
            if (isset($values['title']) && !empty($values['title']))
            {
                $tmpName = $this->translate($bind[$values['title']]);
            }
            elseif (isset($values['type']) && !empty($values['type']) && $type = $this->getTypeName($entityName, $bind[$values['type']]))
            {
                $tmpName = $type;
            }
            else
            {
                $tmpName = $entityName;
            }

            $name = $this->getUniqueName($entityName, $tmpName);

            $values['name'] = ':name';
            $bind[':name']  = $name;

            return ['values'=>$values,'bind'=>$bind];
        }
        return false;
    }

    protected function getUniqueName($entityName, $tmpName)
    {
        $result = $tmpName.'-0';

            $q = [
                'action' => 'SELECT',
                'columns'=> '*',
                'from'   => $entityName,
                'where'  => 'name LIKE :name'
            ];
            $b = [
                ':name' => $tmpName.'-%'
            ];

            $sql = $this->getConvertQuery($q);
            $statement = $this->prepare($sql, $b);
            $statement = $this->execute($statement);
            $exist = $this->getStatementResult($q['action'], $statement);

        if (is_array($exist) && ! empty($exist))
        {
            $lastExist = array_pop($exist)['name'];
            preg_match('#'.$tmpName.'-(\\d+)#',$lastExist,$matches);
            $result = $tmpName.'-'.($matches[1] + 1);
        }

        return $result;
    }


    /**
     * @param string $string
     * @return string|string[]|null
     */
    public function translate(string $string)
    {
        $translit = [
            'а' => 'a', 'б' => 'b', 'в' => 'v', 'г' => 'g', 'д' => 'd', 'е' => 'e', 'ё' => 'e', 'ж' => 'zj', 'з' => 'z',
            'и' => 'i', 'й' => 'i', 'к' => 'k', 'л' => 'l', 'м' => 'm', 'н' => 'n', 'о' => 'o', 'п' => 'p', 'р' => 'r',
            'с' => 's', 'т' => 't', 'у' => 'u', 'ф' => 'f', 'х' => 'kh', 'ц' => 'z', 'ч' => 'ch', 'ш' => 'sh',
            'щ' => 'sch','ы' => 'i','э' => 'e', 'ю' => 'yu', 'я' => 'ya', ' ' => '-', '–' => '-', '—' => '-', '_' => '-'];
        foreach ($translit as $key => $value)
        {
            $pattern = '#['.$key.']#ui';
            $string = preg_replace($pattern,$value,$string);
        }

        $string = preg_replace('#([^A-Za-z0-9\-])#ui','',$string);
        $string = preg_replace('#(-+)#ui','-',$string);
        $string = trim($string,"-");
        return $string;
    }

	/**
	 * @param array $queryParts
	 * @param array $bind
	 * @return mixed
	 * @throws Exception
	 */
	protected function resultDelete(array $queryParts, array $bind)
	{

		// Имя сущности
		$entityName = $queryParts['from'];

		// Составляем список ID всех записей для аптейта
		$idItems = $this->getIdList($entityName, $queryParts['where'], $bind);

		// Определяем условие запроса UPDATE
		$deleteWhere = ['id'=>['in', $idItems]];
		$deleteMetaItemsWhere = ['item_id'=>['in', $idItems]];
		// Определяем строку и bind условий запроса UPDATE
		$deleteWhereResult =$this->recursiveWhere($deleteWhere);
		$deleteMetaItemsWhereResult =$this->recursiveWhere($deleteMetaItemsWhere);

//		debug($deleteWhereResult,$deleteMetaItemsWhereResult);


		// Составляем основной запрос DELETE
		$deleteParts = [
			'action'=> 'DELETE',
			'from' => $entityName,
			'where' => $deleteWhereResult['where']
		];
		// Составляем bind для основного запроса DELETE
		$deleteBind = $deleteWhereResult['bind'];
		// Выполняем основной запрос UPDATE
		$deleteSql = $this->getConvertQuery($deleteParts);
		$statement = $this->prepare($deleteSql, $deleteBind);
		$statement = $this->execute($statement);
		$result = $this->getStatementResult($deleteParts['action'], $statement);
//		debug($deleteSql,$deleteBind);


		// Составляем дополнительные запрос DELETE
		$deleteParts = [
			'action'=> 'DELETE',
			'from' => $entityName.'_meta',
			'where' => $deleteMetaItemsWhereResult['where']
		];
		// Составляем bind для дополнительного запроса DELETE
		$deleteBind = $deleteMetaItemsWhereResult['bind'];
		// Выполняем дополнительные запрос DELETE
		$deleteSql = $this->getConvertQuery($deleteParts);
		$statement = $this->prepare($deleteSql, $deleteBind);
		$statement = $this->execute($statement);
		$this->getStatementResult($deleteParts['action'], $statement);
//		debug($deleteSql,$deleteBind);

		return $result;
	}

	/**
	 * @param string $entityName
	 * @param array $where
	 * @param array $bind
	 * @return array
	 * @throws Exception
	 */
	protected function getIdList(string $entityName, string $where, array $bind)
	{
		// Имя сущности
//		$entityName = $queryParts['table'];

		// Составляем запрос SELECT для поиска записей для апдейта
		$selectParts = [
			'action'    => 'SELECT',
			'columns'   => '*',
			'from'      => $entityName,
			'where'     => $where
		];
		// Составляем bind для поиска записей для апдейта
		$selectBind = [];
		foreach ($bind as $key => $value)
		{
			if (strpos($selectParts['where'],$key))
				$selectBind[$key] = $value;
		}
		// Ищем все записи для апдейта
		$resultSelect = $this->resultSelect($selectParts, $selectBind);
		// Составляем список ID всех записей для аптейта
		$idItems = [];
		foreach ($resultSelect as $key => $item)
		{
			$idItems[] = $item['id'];
		}

		return $idItems;
	}

	/**
	 * @param array $queryParts
	 * @param array $bind
	 * @return bool
	 * @throws Exception
	 */
	protected function resultUpdate(array $queryParts, array $bind)
	{

		//TODO: Сократить метод

		// Имя сущности
		$entityName = $queryParts['table'];

		// Составляем список ID всех записей для аптейта
		$updateIDs = $this->getIdList($entityName, $queryParts['where'], $bind);

		// Определяем условие запроса UPDATE
		$updateWhere = ['id'=>['in', $updateIDs]];
		$updateMetaItemsWhere = ['item_id'=>['in', $updateIDs]];
		// Определяем строку и bind условий запроса UPDATE
		$updateWhereResult =$this->recursiveWhere($updateWhere);
		$updateMetaItemsWhereResult =$this->recursiveWhere($updateMetaItemsWhere);

		// Определяем колонки для запроса UPDATE
		$columns = $this->getTableColumns($entityName);
		$metaKeys = $this->getEntityMetaKeys($entityName);

		// Определяем значения для запроса UPDATE
		$updateSet = array_intersect_key($queryParts['set'],array_flip($columns));
		$updateMetaSet = array_diff_key($queryParts['set'],$updateSet);

		// Составляем основной запрос UPDATE
		$updateParts = [
			'action'=> 'UPDATE',
			'table' => $entityName,
			'set'   => $updateSet,
			'where' => $updateWhereResult['where']
		];
		// Составляем bind для основного запроса UPDATE
		$updateBind = array_merge(
			array_intersect_key(
				$bind,
				array_flip($updateSet)
			),
			$updateWhereResult['bind']
		);
		// Выполняем основной запрос UPDATE
		$updateSql = $this->getConvertQuery($updateParts);
		$statement = $this->prepare($updateSql, $updateBind);
		$statement = $this->execute($statement);
		$result = is_int($this->getStatementResult($updateParts['action'], $statement)); // bool


		// Составляем запрос SELECT для поиска всех мета для апдейта
		$selectMetaParts = [
			'action'    => 'SELECT',
			'columns'   => '*',
			'from'      => $entityName.'_meta',
			'where'     => $updateMetaItemsWhereResult['where']
		];
		// Составляем bind для поиска всех мета для апдейта
		$selectMetaBind = $updateMetaItemsWhereResult['bind'];
		// Ищем все записи для апдейта

		// Выполняем запрос SELECT для всех мета для апдейта
		$selectMetaSql = $this->getConvertQuery($selectMetaParts);
		$statement = $this->prepare($selectMetaSql, $selectMetaBind);
		$statement = $this->execute($statement);
		// Получаем все элементы для апдейта
		$resultMetaSelect = $this->getStatementResult($selectMetaParts['action'], $statement);
		// Переводим все элементы для апдейта в более удобный вид
		$metaToUpdate = [];
		foreach ($resultMetaSelect as $meta)
		{
			$metaToUpdate[$meta['item_id']][$meta['meta_key']] = $meta['meta_value'];
		}

		// Список ID элементов для апдейта
		$listMetaItems = $updateMetaItemsWhereResult['bind'];

//		debug($queryParts['set'],$updateMetaSet);
		foreach ($updateMetaSet as $metaKey => $bindKey)
		{
			// Составляем дополнительный запрос UPDATE для одного meta_key
			$updateMetaParts = [
				'action'=> 'UPDATE',
				'table' => $entityName.'_meta',
				'set'   => ['meta_value'=>$bindKey],
				'where' => $updateMetaItemsWhereResult['where'] . " && meta_key='" . $metaKey . "'"
			];
			// Составляем bind для дополнительного запроса UPDATE для одного meta_key
			$updateMetaBind = array_merge(
				array_intersect_key(
					$bind,
					[$bindKey=>false,]
				),
				$updateMetaItemsWhereResult['bind']
			);
			// Выполняем дополнительный запрос UPDATE для одного meta_key
			$updateMetaSql = $this->getConvertQuery($updateMetaParts);
			$statement = $this->prepare($updateMetaSql, $updateMetaBind);
			$statement = $this->execute($statement);
			$resultMetaUpdate = $this->getStatementResult($updateMetaParts['action'], $statement);
//			debug($updateMetaSql, $updateMetaBind, $resultMetaUpdate);

			foreach ($listMetaItems as $metaItemId)
			{
				if (!isset($metaToUpdate[$metaItemId][$metaKey]))
				{
					$insertMetaId = $this->insertMetaValue($entityName, $metaItemId, $metaKey, $bind[$bindKey]);
//					debug('insert', $insertMetaId);
				}
			}

		}
		return $result;
	}

	/**
	 * @param $entityName
	 * @param $itemId
	 * @param $metaKey
	 * @return array|bool|string
	 * @throws Exception
	 */
	protected function selectMetaValue($entityName, $itemId, $metaKey)
	{
		$metaParts = [
			'action' => 'SELECT',
			'from'   => "{$entityName}_meta",
			'where' => [
				'item_id'   =>  ':item_id',
				'meta_key'  =>  ':meta_key'
			]
		];
		$metaBind = [
			':item_id'    => $itemId,
			':meta_key'   => $metaKey
		];
		$metaQuery = $this->getConvertQuery($metaParts);
		$stmt = $this->prepare($metaQuery, $metaBind);
		$stmt = $this->execute($stmt);
		$result = $this->getStatementResult($metaParts['action'], $stmt);
		return $result;
	}

	/**
	 * @param $entityName
	 * @param $itemId
	 * @param $metaKey
	 * @param $metaValue
	 * @return array|bool|string
	 * @throws Exception
	 */
	protected function insertMetaValue($entityName, $itemId, $metaKey, $metaValue)
	{
		$metaParts = [
			'action' => 'INSERT',
			'into'   => "{$entityName}_meta",
			'values' => [
				'item_id'   =>  ':item_id',
				'meta_key'  =>  ':meta_key',
				'meta_value'=>  ':meta_value'
			]
		];
		$metaBind = [
			':item_id'    => $itemId,
			':meta_key'   => $metaKey,
			':meta_value' => $metaValue
		];
		$metaQuery = $this->getConvertQuery($metaParts);
		$stmt = $this->prepare($metaQuery, $metaBind);
		$stmt = $this->execute($stmt);
		$metaId = $this->getStatementResult($metaParts['action'], $stmt);
		return $metaId;
	}

	/**
	 * @param string $entityName
	 * @param array $result
	 * @return array
	 * @throws Exception
	 */
	protected function resultSelectDiscardExcess(string $entityName, array $result)
	{
		$columnNames = [];
		foreach ($result as $key => $item)
		{
			if (isset($item['type']))
			{
				if (!key_exists($item['type'], $columnNames))
					$columnNames[$item['type']] = $this->getEntityTypeColumns($entityName, $item['type']);
				$result[$key] = array_intersect_key($item,array_flip($columnNames[$item['type']]));
			}
		}
		return $result;
	}




	/**
	 * @param string $entityName
	 * @param string $typeName
	 * @return array
	 * @throws Exception
	 */
	protected function getEntityTypeColumns(string $entityName, string $typeName)
	{
		$columns = $this->getTableColumns($entityName);
		$metaKeys = $this->getTypeMetaKeys($entityName, $typeName);
		$all = array_unique(array_merge($columns, $metaKeys));
		return $all;
	}

    /**
     * @param string $entityName
     * @param string $typeName
     * @return false|int|string
     * @throws Exception
     */
    protected function getTypeId(string $entityName, string $typeName)
    {
        $types = $this->getEntityTypes($entityName);
        $id = array_search($typeName, $types);
        return $id;
    }

    /**
     * @param string $entityName
     * @param string $typeId
     * @return bool|mixed
     * @throws Exception
     */
    protected function getTypeName(string $entityName, string $typeId)
    {
        $types = $this->getEntityTypes($entityName);
        return isset($types[$typeId]) ? $types[$typeId] : false;
    }

	/**
	 * @param $entityName
	 * @return mixed
	 * @throws Exception
	 */
	protected function getEntityMetaKeys($entityName)
	{
		$keys = isset($this->entities[$entityName]['keys']) ? $this->entities[$entityName]['keys'] : null;
		if ($keys !== false && !(is_array($keys) && !empty($keys)))
		{
			$stmt = $this->prepare("SELECT * FROM {$entityName}_keys", []);
			$stmt = $this->execute($stmt);
			$result = $this->getStatementResult('SELECT', $stmt);

			$keys = $result;
			$this->entities[$entityName]['keys'] = $keys;
		}
		return $this->entities[$entityName]['keys'];
	}

	/**
	 * @param $entityName
	 * @param $typeName
	 * @return array
	 * @throws Exception
	 */
	protected function getTypeMetaKeys($entityName, $typeName)
	{
		$typeId = $this->getTypeId($entityName, $typeName);
		$result = [];
		$keys = $this->getEntityMetaKeys($entityName);
		if (is_array($keys) && !empty($keys))
		{
			foreach ($keys as $key)
			{
				if ($key['type'] == $typeId || $key['type'] == null)
				{
					$result[] = $key['meta_key'];
				}
			}
		}
		return $result;
	}

	/**
	 * @param $table
	 * @return mixed
	 * @throws Exception
	 */
	protected function getTableColumns($table)
	{
		if (empty($this->entities[$table]['columns']))
		{
			$stm = $this->prepare("SHOW COLUMNS FROM {$table}", []);
			$stm = $this->execute($stm);
			$columns = $this->getStatementResult('SHOW',$stm);
			foreach ($columns as $column)
			{
				$this->entities[$table]['columns'][] = $column['Field'];
			}
		}

		return $this->entities[$table]['columns'];
	}

}